\documentclass{common/cs157}
\usepackage{hyperref}
% \usepackage{clrscode}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{listings}


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[shortlabels]{enumitem}

\newenvironment{problem}[1]{
  \subsubsection*{Problem #1}
}



% comment this in if you want to compile the solution key:
% \sol


\hwk{3}
\due{October 5, 2021 at 14:30 ET}


\begin{document}

\homeworkhandin % this is in common/cs157.cls if you need to edit it

\begin{problem}{1}
Generalize Huffmanâ€™s algorithm to ternary codewords (i.e., codewords using the symbols 0,1, and 2). Argue its correctness and optimality. Analyze its runtime.
\end{problem}

\newpage

\begin{problem}{2}
\begin{enumerate}[a.]
    \item Let $G=(V,E)$ be an undirected graph. Using the definition of a matroid, show that $(E, l)$ is a matroid. Where $A \in l$ if and only if $A$ is an acyclic subset of $E$.
    \item Let $w:E\rightarrow R+$ be a function that assigns a non-negative weight to each element of $E$. Give an efficient algorithm to find an acyclic subset of $E$ of maximum weight. Analyze runtime and argue correctness/optimality.
\end{enumerate}
\end{problem}

\newpage

\begin{problem}{3}
Suppose you are given a set $S=\{a_1, a_2, ..., a_n\}$ of tasks, where task $a_i$ requires $p_i$ units of processing time to complete, once it has started. You have on computer on which to run these tasks, and the computer can run only one task at a time. Let $c_i$ be the \emph{\textbf{completion time}} of task $a_i$, that is the time at which task $a_i$ completes the processing. Your goal is to minimize the average completion time, that is, to minimize $(1/n)\sum_{i=1}^{n}c_i$. For example, suppose there are two tasks, $a_1$ and $a_2$, with $p_1 = 3$ and $p_2 = 5$, and consider the schedule in which $a_2$ runs first, followed by $a_1$. Then, $c_2 = 5, c_1 = 8$, and the average completion time is $(5 + 8) / 2 = 6.5$.
\begin{enumerate}[a.]
    \item Give an algorithm that schedules the tasks so as to minimize the average completion time. Each task must run non-preemptively, that is, once task $a_i$ is started, it must run continuously for $p_i$ units of time. Prove that your algorithm minimizes the average completion time, and state the running time of your algorithm. 
    \item Suppose now that the tasks are not all available at once. That is, each task has a \textbf{\textit{release time}} $r_i$ before which it is not available to be processed. Suppose also that we allow \textbf{\textit{preemption}}, so that a task can be suspended and restarted at a later time. For example, a task $a_i$ with processing time $p_i = 6$ may start running at time 1 and be preempted at time 4. It can then resume at time 10 but be preempted at time 11 and finally resume at time 13 and complete at time 15. Task $a_i$ has run for a total of 6 time units, but its running time has been divided into three pieces. We say that the completion time of $a_i$ is 15. Give an algorithm that schedules the tasks so as to minimize the average completion time in this new scenario. Prove that your algorithm minimizes the average completion time, and state the running time of your algorithm. 
\end{enumerate}
\end{problem}
\newpage
\begin{problem}{4 - Multiple Classes Fractional Knapsack}
Consider a variation of the Fractional Knapsack discussed in class, for which each item in $S$ is assigned to a single \emph{class} $\{1,2,\ldots, k\}$.  That is each item in $S$ is a triple of values $(b_i,w_i,c_i)$ where $b_i$ is the benefit of the $i$-th item, $w_i$ is its weight, and $c_i$ is its class.


The goal of the problem is still to select items for our knapsack in a way that maximizes the overall benefit without exceeding a given allowable weight $W>0$. However, only one item may be chosen among those assigned to the same subclass. Recall, that in this \emph{fractional} variant, it is possible to select an arbitrary fraction of each item. 

Consider the following algorithm (note that the algorithm returns a list of (element, fraction of element taken) tuples):

\begin{itemize}
    \item For each item in $S$ compute its value as $v_i =b_i/w_i$.
    \item For each of the $k$ classes, sort the items in each class in non-increasing order of their value $v_i$.
    \item Let $S_j$, for $j\in \{1,2,\ldots, k\}$ denote the item of maximum value among those in the class $j$. If there are multiple items in $j$ with the same, maximum value pick the one with maximum weight. 
    \item Invoke the procedure \textsc{MCFknapsack}$(\{S_1,S_2,\ldots,S_k\}, W)$. 
    \begin{enumerate}
        \item If $W=0$, return $\emptyset$.
        \item Otherwise, pick the item with highest value among those in $\{S_1,S_2,\ldots,S_k\}$. Let $e$ denote such element, let $w_e$ denote its weight, and let $j$ denote its class. 
        \item return $\{(e, \min (1, W/w_e))\}\cup \textsc{MCFknapsack}(\{S_1,S_2,\ldots,S_k\}\setminus S_j, \max\{0,W-w_e\})$
    \end{enumerate}
\end{itemize}


\begin{enumerate}
    \item[a.] Is this a greedy algorithm? Motivate your answer.
    \item[b.] Is this algorithm optimal? Motivate you answer.
\end{enumerate}
\end{problem}

\end{document}