\documentclass{common/cs157}
\usepackage{hyperref}
% \usepackage{clrscode}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{listings}


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[noframe]{showframe}
\usepackage{framed}
\usepackage[shortlabels]{enumitem}

\renewenvironment{shaded}{%
  \def\FrameCommand{\fboxsep=\FrameSep \colorbox{shadecolor}}%
  \MakeFramed{\advance\hsize-\width \FrameRestore\FrameRestore}}%
 {\endMakeFramed}
\definecolor{shadecolor}{gray}{0.9}


% comment this in if you want to compile the solution key:
% \sol


\hwk{8}
\due{November 23, 2021}


\begin{document}

\homeworkhandin % this is in common/cs157.cls if you need to edit it

\begin{problem}{1}
\begin{enumerate}
    \item Suppose we are given a sequence  $Q=\{q_0,q_1,\ldots,q_{n-1}\}$ of points in $\mathbb{R}^2$ such that $q_0$ is the anchor and $q_1,q_2,\ldots,q_{n-1}$ are the other vertices on the convex hull in counterclockwise order starting from the anchor. 
    Describe an algorithm that given $Q$ and a new point $(x,y)\in\mathbb{R}^2$ construct in linear time a sequence $Q'$ which is the convex hull of the points in $Q$ and the new point $(x,y)$. Show that your proposed algorithm is correct and analyze its running time. 
    \item In the \emph{on-line convex-hull problem}, we are given the set  $P$ of $n$ points one point at a time. After receiving each point, we are to compute the convex hull of the points seen so far
    \begin{enumerate}
        \item Propose an algorithm that uses  the Graham scan so that  after $n$ points the overall running time is $O(n^2\log n)$. Prove the correctness and analyze the running time of the proposed algorithm.
        \item Show how to improve this slightly, by showing we can solve the online convex hull problem in $O(n^2)$. Prove the correctness and analyze the running time of the proposed algorithm.
    \end{enumerate}
\end{enumerate}
\end{problem}
% \begin{problem}{1}

% One way to mask a message, $M$, using a version of steganography, is to insert
% random characters into $M$ at pseudo-random locations so as to expand M into a
% larger string, $C$. For instance, the message,
% \begin{center}
%     ILOVEMOM
% \end{center}
% could be expanded into
% \begin{center}
%     AMIJLONDPVGEMRPIOM
% \end{center}
% It is an example of hiding the string, $M$, in plain sight, since the characters in
% $M$ and $C$ are not encrypted. As long as someone knows where the random characters where inserted, he or she can recover $M$ from $C$. The challenge for
% law enforcement, therefore, is to prove when someone is using this technique,
% that is, to determine whether a string $C$ contains a message $M$ in this way. Thus,
% describe an $O(n)$-time method for detecting if a string, $M$, is a subsequence of a
% string, $C$, of length $n$.

% \end{problem}

\newpage
%% DO NOT DELETE PLEASE :)
% \begin{problem}{2}

% Let $P$ and $Q$ be two disjoint convex polygons with n vertices each. There is no horizontal overlap between the polygons, i. e. you can split the 2 by a vertical line that intersects neither polygon.

% $P$ is represented as a list starting with anchor point $a$ and the remaining points of $P$ (that is, $P - \{a\}$) sorted counterclockwise by angle around $a$. The same applies to $Q$.

% \begin{enumerate}[a.]

%     \item 
%     Give an O(n) time algorithm that computes the convex hull of $P \cup Q$. 

%     \item
%     Use the algorithm from part (a) to develop an O(n $\log$ n) time divide-and-conquer algorithm to compute the convex hull of a set of n points in a plane.
    
%     !!! DIRECTION ONE
%     These points are sorted by x-coordinate.
    
    
%     !!! DIRECTION TWO
%     Assume you have access to a $median$ function that computes median of a list in $O(n)$.  
%     \end{enumerate}
% \end{problem}
\newpage
% \begin{problem}{3}
% Linguists are interested in studying the way in which words are constructed, with common prefixes and suffixes giving clues to the meaning of words they are contained in. Thus, a useful tool for a linguist would be able to identify all the words in a given collection, $W$, of words, that have the same prefix, $p$, or suffix $s$. It is useful to even just know the number of such words in $W$. Describe how to construct a data structure that can efficiently answer, for any prefix $p$, or suffix $s$, how many words in $W$ have the prefix $p$ or the suffix $s$. What is the required time to build the data structure, and to query the data structure?

% !!!NEEDS REVIEW: sub question:
% Now suppose your prefix or suffix should support for spacial character ‘.’ which matches any character in its position. How would you modify your algorithm?


% \end{problem}

% \newpage
\begin{problem}{2}
        Line segments and polygons are used to model geometric objects in computer graphics, video games, and computer-aided design. Suppose you are given a set $S$, of $n$ line segments, in no particular order. Describe an efficient algorithm for determining whether the segments of $S$ form a polygon, $P$, and if so, give a polygonal representation for $P$. You may allow $P$ to be non-simple (that is, self-intersecting), but $P$ must be a single cyclical chain of vertices connected by the \textit{unique} segments in $S$. An easy way to think of this definition a polygon $P$ is that $P$ must be able to be formed by one piece of string, where the beginning of the string touches the end of the string, and no segments of the string lie on top of other segments. What is the running time of your algorithm?
\end{problem}
\newpage
\begin{problem}{3}
Show how to extend the Rabin-Karp method to handle the problem of looking for a given $m\times m$ pattern in an $n\times n$ array of characters. Describe the overall algorithm and how you would approach computing the hashcodes used in Rabin-Karp. Your algorithm should not use more than $O(m)$ additional memory and should require at most $O(n^2m)$ time. Prove the correctness of your solution, analyze its running time and memory space utilization.
\end{problem}
\end{document}