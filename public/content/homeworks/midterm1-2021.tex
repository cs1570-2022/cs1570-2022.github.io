\documentclass{common/cs157}
\usepackage{hyperref}
% \usepackage{clrscode}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{listings}


\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[noframe]{showframe}
\usepackage{framed}
\usepackage[shortlabels]{enumitem}

\renewenvironment{shaded}{%
  \def\FrameCommand{\fboxsep=\FrameSep \colorbox{shadecolor}}%
  \MakeFramed{\advance\hsize-\width \FrameRestore\FrameRestore}}%
 {\endMakeFramed}
\definecolor{shadecolor}{gray}{0.9}


% comment this in if you want to compile the solution key:
% \sol


\mdtrm{1}
\due{October.\ 28, 2021}



\begin{document}
\midtermpolicyremind{}

\begin{problem}{1 - 10 points}
Let $X[1,\ldots,n]$ and $Y[1,\ldots,n]$ be two arrays, each containing $n$ numbers already in sorted - non decreasing - order. For simplicity assume $n$ is a power of $2$, Give an $O(\log n)$-time algorithm to find the median of all $2n$ elements in arrays $X$ and $Y$.
\begin{enumerate}
    \item[(a)] Provide a succinct (but clear) description of your algorithm. You may provide a pseudocode.
    \item[(b)] Provide a proof of the correctness of the algorithm.
    \item[(c)] Provide an analysis of the running time (asymptotic analysis is correct) and memory utilization of the algorithm.
\end{enumerate}
\noindent \emph{Hint:} Note that the given arrays are already sorted and of the \textbf{same size}! You may want to use log search to exploit this fact :)
\end{problem}

% \begin{problem}{2}
% Lorenzo has decided to make a roadtrip to the Grand Canyon over the summer and he wants to plan his stops. When full, his car holds enough gas to travel $m$ miles. Lorenzo has a map that gives the distance between all gas stations on his route. Lorenzo hates stopping so he would like to make as few gas stops as possible along the way. Give an efficient algorithm by which Lorenzo can decide at which gas stations he should stop without getting stranded along the way, analyze its runtime, and prove that it is optimal. 
% \end{problem}

\begin{problem}{2 - 10 points}
Provide an efficient greedy algorithm that given a set $\{x_1,x_2,\ldots,x_n\}$ of points on the real line, determines the smallest set of  closed intervals of length 3 that contains all of the given points.
\begin{enumerate}
    \item[(a)] Provide a succinct (but clear) description of your algorithm. You may provide a pseudocode.
    \item[(b)] Prove the correctness (optimality) of your algorithm.
    \item[(c)] Provide an analysis of the running time (asymptotic analysis is correct) and memory utilization of the algorithm.
\end{enumerate}
\end{problem}


\begin{problem}{3 - 10 points}
You have been hired by a top 500 corporation...Congratulations (I guess)!!!You first job is to plan a company party. The company has a hierarchical structure, that is the supervisor relation forms a tree rooted at the president. The HR department has assigned each company employee with a conviviality ranking which is a positive real number. In order to avoid awkwardness, the president of the company does not want both an employee and their immediate supervisor to attend. You are given the tree that describes the company's structure and the conviviality scored of all employees. Describe a Dynamic Programming algorithm that compiles a guest list which maximizes the sum of conviviality scores of the guests.
\begin{enumerate}
    \item[(a)] Provide a succinct (but clear) description of your algorithm. You may provide a pseudocode.
    \item[(b)] Provide a proof that the algorithm returns a correct (i.e., does not violate the rules) and optimal guest list (i.e., a list with maximum possible conviviality score among the possible correct guest lists).
    \item[(c)] Provide an analysis of the running time (asymptotic analysis is correct) and memory utilization of the algorithm.
\end{enumerate}

\end{problem}

\begin{problem}{4 -10 points}
\begin{enumerate}
    \item[(a)]Give an efficient divide and conquer algorithm to convert a given $n$-bit binary integer to a decimal representation and prove its correctness. For simplicity, assume $n$ is a power of $2$.
    \item[(b)] Analyze the running time of your algorithm. Assume that is possible to multiply two decimal integer numbers with $n$ digits in $O(n^{log_2 3})$ time. 
\end{enumerate}

\emph{Hint:} Recall that a given a $n$-digits integer $x$ is expressed in binary as $x=(x_{n-1},x_{x_2},\ldots, x_1,x_0)_2$
where $x_0$ is its least significant digit and $x_{n-1}$ is its most significant digit. Further, let $x_l=(x_{n/2-1},x_{n/2-2},\ldots,x_1,x_0)_2$ be the $n/2$-digit integer in binary which corresponds to the $n/2$ least significant digits of $x$, and let $x_m=(x_{n-1},x_{n-2},\ldots,x_{n/2+1},x_{n/2})_2$ be the $n/2$-digit integer in binary which corresponds to the $n/2$ most significant digits of $x$. We have $x=x_l+2^{n/2}*x_m$. This should suggest us a way to set up a divide and conquer strategy...:) Careful about the number of subproblems!
\end{problem}

\end{document}